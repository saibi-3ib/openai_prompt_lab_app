# Production deployment checklist and required settings

このドキュメントは、ローカル開発で使っている設定（緩和した CSP、デベロップ用フラグ、自己署名 HTTPS、SESSION_COOKIE_SECURE = False など）を本番環境へデプロイする際に確認・変更すべき環境変数、設定、コードの一覧と手順をまとめたものです。  
開発中の緩和設定をそのまま本番に持っていくとセキュリティ上の重大なリスク（CSRF 回避不能、XSS の許容、HTTPS 非常時のクッキー漏洩など）につながるため、デプロイ前に必ず以下の項目をチェックしてください。

目次
- 必須環境変数（本番）
- 開発用設定 → 本番で変更/削除すべき項目（コード差分の具体例）
- サービス/インフラ要件（推奨構成）
- 設定ファイルのサンプル（.env.production、nginx、gunicorn systemd）
- デプロイ前チェックリスト（手順とコマンド）
- トラブルシュートの短いヒント（今回発生した事例）
- 付録：よく使う curl / デバッグコマンド

---

## 1) 必須環境変数（本番で必ず設定する）
以下は本番環境で必ず用意・固定しておくべき環境変数です。秘密は安全にシークレットストア（Vault, AWS Secrets Manager, GitHub Secrets, etc.）で管理してください。

- FLASK_SECRET_KEY (必須)  
  - 用途: Flask セッションの署名、Flask-WTF/CSRF トークンなど。常に固定で長いランダム値を使う（例: secrets.token_urlsafe(32)）。
  - 例: FLASK_SECRET_KEY="pX9...longrandom..."

- DATABASE_URL (必須)  
  - SQLAlchemy 接続先。例: postgresql://user:pass@host:5432/dbname

- RATELIMIT_STORAGE_URI (推奨)  
  - Flask-Limiter の永続ストレージ (Redis 推奨)。例: redis://:password@redis-host:6379/0

- DISABLE_FORCE_HTTPS (本番では False / 未設定にする)  
  - 開発で一時的に HTTPS 強制を無効化している場合に使用。生産環境では無効化しない（値は削除か False）。

- WORKER_CONFIRM_PHRASE (任意だが推奨)  
  - admin_worker 用の確認フレーズ。デフォルトは "RUN_WORKER"。本番は強固なフレーズに変更。

- ADMIN_USERS (任意)  
  - User モデルに is_admin が無い場合に使う管理者ユーザ名のカンマ区切りリスト。より安全には DB 内の is_admin を使う。

- SENTRY_DSN / LOGGING_*（任意）  
  - 監視/エラートラッキング用。

- FLASK_ENV / ENVIRONMENT (推奨)  
  - production を明示。FLASK_ENV=production

- DISABLE_WTF_CSRF (開発用/本番では必ず OFF)  
  - 開発用一時無効化フラグ。絶対に本番で 1 にしないこと。

---

## 2) 開発用設定 → 本番で変更/削除すべき項目（具体的修正箇所）

以下は、開発時に行った緩和や一時処置を本番に戻すための具体例です。run.py / app/security.py / テンプレートの差分を参考にしてください。

A) run.py: セッション cookie / SECRET_KEY の扱い
- 開発用（example）:
```python
# (dev)
app.config.setdefault('SECRET_KEY', os.environ.get('FLASK_SECRET_KEY') or 'change-me-locally')
app.config.setdefault('SESSION_COOKIE_SECURE', False)
```
- 本番での修正（必須）:
```python
# (production)
app.config['SECRET_KEY'] = os.environ['FLASK_SECRET_KEY']  # 必ず存在させる（KeyError で fail-fast）
app.config['SESSION_COOKIE_SECURE'] = True  # HTTPS 下でのみ送信
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'  # or 'Strict' depending on needs
```
注意: `app.secret_key = ...` と `app.config['SECRET_KEY']` のどちらか一方で一貫して設定してください。

B) CSRF: DISABLE_WTF_CSRF
- 開発用一時無効化をした場合は必ず削除:
```python
# 削除または False にする
app.config['WTF_CSRF_ENABLED'] = True
# DISABLE_WTF_CSRF 環境変数を本番で使わない
```

C) Talisman / CSP: app/security.py
- 開発で採用した緩和 (例: 'unsafe-inline', cdn.jsdelivr) を本番では削除（厳格化）。本番サンプル:
```python
csp = {
    "default-src": ["'self'"],
    "script-src": ["'self'"],  # remove cdn and 'unsafe-inline'
    "style-src": ["'self'"],   # Tailwind self-host or build CSS
    "img-src": ["'self'", "data:"],
    # add other directives as required
}
Talisman(app, content_security_policy=csp, force_https=True, strict_transport_security=True)
```
- 代替: CDN を使う場合は script/style のハッシュ（sha256-...）か nonce を使って CSP を厳格にして下さい。

D) Flask-Limiter: 永続ストレージに切替え
- 開発（in-memory）は本番不可。設定例:
```python
# 環境変数
export RATELIMIT_STORAGE_URI="redis://:password@redis-host:6379/0"
# app/security.py の Limiter 初期化 (例)
limiter = Limiter(app=app, key_func=get_remote_address, storage_uri=os.environ.get('RATELIMIT_STORAGE_URI'))
```

E) Static assets (Tailwind / Autolinker)
- 開発では CDN と inline を許可していましたが、本番では self-host を推奨:
  - Tailwind: PostCSS または Tailwind CLI でビルドして `static/css/style.css` に配置
  - Autolinker: vendor ファイルを static に置く
  - テンプレの外部参照を `{{ url_for('static', filename=...) }}` に置き換える

F) Worker runner (admin_worker)
- WORKER_CONFIRM_PHRASE を確認し、PID ファイル管理、ログ出力のパーミッションなどをチェック

---

## 3) サービス / インフラ（推奨構成）

- WSGI サーバ: Gunicorn / Uvicorn + workers
  - 例: gunicorn -w 3 -k gthread -b 127.0.0.1:8000 run:app
- リバースプロキシ: nginx (TLS termination), 証明書は Let's Encrypt (certbot) で取得
- DB: PostgreSQL (推奨) with backups and migrations (Alembic)
- Redis: rate limiter storage + cache
- ロギング/監視: Sentry, Prometheus + Grafana 等
- CI/CD: GitHub Actions (テスト → build → deploy)
- Secrets management: Vault / AWS Secrets Manager / GitHub Actions Secrets

---

## 4) 設定ファイルのサンプル

A) .env.production (サンプル、実運用では secret はファイルではなくシークレットマネージャへ)
```
FLASK_ENV=production
FLASK_SECRET_KEY=put_a_strong_random_key_here
DATABASE_URL=postgresql://user:pass@db.example.com:5432/app_db
RATELIMIT_STORAGE_URI=redis://:redispass@redis.example.com:6379/0
WORKER_CONFIRM_PHRASE=RUN_WORKER_IN_PROD
ALLOW_DB_RESET=0
ADMIN_USERS=alice,bob
DISABLE_FORCE_HTTPS=0
```

B) nginx (TLS termination, proxy to Gunicorn)
```nginx
server {
    listen 80;
    server_name example.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name example.com;

    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;

    location /static/ {
        alias /srv/app/current/static/;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000";
    }

    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_pass http://127.0.0.1:8000;
        proxy_read_timeout 120;
    }
}
```

C) systemd unit (gunicorn)
```ini
[Unit]
Description=Gunicorn instance to serve myapp
After=network.target

[Service]
User=www-data
Group=www-data
WorkingDirectory=/srv/app/current
EnvironmentFile=/srv/app/current/.env.production
ExecStart=/srv/app/venv/bin/gunicorn -w 3 -k gthread -b 127.0.0.1:8000 run:app

[Install]
WantedBy=multi-user.target
```

---

## 5) デプロイ前チェックリスト（コマンド付き）

1. secret の配置
   - FLASK_SECRET_KEY と DATABASE_URL を設定。確認:
     ```bash
     echo $FLASK_SECRET_KEY
     echo $DATABASE_URL
     ```

2. セキュリティ設定を本番用に戻す（CSP, SESSION_COOKIE_SECURE=True, Talisman.force_https=True）

3. 静的ファイルをビルドして配置（Tailwind の場合）
   - 例（Node が整備されている前提）:
     ```bash
     npm ci
     npx tailwindcss -i ./src/input.css -o ./static/css/style.css --minify
     ```
   - Autolinker 等の vendor を static に配置。

4. Gunicorn 起動（ローカルで検証）
   ```bash
   FLASK_ENV=production FLASK_SECRET_KEY=... DATABASE_URL=... gunicorn -w 3 -b 127.0.0.1:8000 run:app
   ```
   - ブラウザ/ curl で http://127.0.0.1:8000/ が 302 -> /login など正常に動くか確認。

5. nginx 経由で HTTPS をテスト（本番ホスト上で）
   - 証明書: certbot を使う
   - curl で検証:
     ```bash
     curl -vk https://example.com/   # -k は自己署名を無視する時のみ
     ```

6. CSRF / Session の検証
   - login ページを取得して Set-Cookie が付き、hidden csrf_token が埋まっていることを確認:
     ```bash
     curl -v -c cookies.txt https://example.com/login -o login_page.html
     grep 'csrf_token' login_page.html
     ```
   - 取得した cookie と token で POST し、403 にならないことを確認。

7. CSP の確認
   ```bash
   curl -I https://example.com/ | grep -i content-security-policy
   ```
   - 必要に応じて CSP header を調整（推奨: self-hosted assets + hashes/nonce）

8. Rate limiter check
   - RATELIMIT_STORAGE_URI が Redis を指しているか確認

9. Monitoring & logging
   - Sentry / ログローテーション / access logs を有効にする

---

## 6) トラブルシュート（今回の実例からの短い教訓）

- 事象: ブラウザや curl が `Bad request version`（TLS handshake のバイナリ）や、`Server: AirTunes` のような予期しないヘッダを返す場合  
  - 原因: 期待した Flask がポートをリッスンしておらず、別プロセスが同ポートを占有していた。  
  - 対処:
    - `lsof -nP -iTCP:5000 -sTCP:LISTEN` で占有プロセスを確認
    - Flask を別ポート（例: 5001/8000）で起動するか、占有プロセスを確認・停止する
    - ブラウザの HSTS キャッシュが原因で HTTPS に強制される場合は別ブラウザ/プライベートウィンドウで確認、もしくは自己署名で HTTPS を一時有効にする

- 事象: CSP により外部 CDN のスクリプトや inline スクリプトがブロックされ `Autolinker is not defined` 等のエラーが出る  
  - 原因: 開発時に緩和していた CSP を本番で厳格化する前に外部スクリプトを残した。  
  - 対処:
    - 本番では外部スクリプトを self-host する or CSP に該当スクリプトのハッシュ/nonce を追加する

- 事象: CSRF 検証で 403 になる  
  - 原因: セッション cookie が送られていない（SESSION_COOKIE_SECURE=True のまま HTTP 接続しているなど）、SECRET_KEY が一致していない、またはリクエストが別サーバに当たっていた  
  - 対処:
    - SESSION_COOKIE_SECURE は HTTPS の場合 True。開発で HTTP を使う場合は False にしておく
    - SECRET_KEY を固定する（環境変数）
    - リクエストが期待するサーバに届いているか `lsof`/`curl` で確認

---

## 7) 付録：よく使うデバッグコマンド（短い）

- ポート使用状況確認
  ```bash
  lsof -nP -iTCP:5000 -sTCP:LISTEN
  ```

- view_functions / url map を確認（Flask アプリの内部）
  ```bash
  python - <<'PY'
  from run import app
  print(sorted(app.view_functions.keys()))
  for r in app.url_map.iter_rules():
      print(r.endpoint, r)
  PY
  ```

- login ページの CSRF + cookie を curl で確認
  ```bash
  curl -v -c cookies.txt https://example.com/login -o login_page.html
  sed -n 's/.*name="csrf_token" value="\([^"]*\)".*/\1/p' login_page.html | head -n1
  ```